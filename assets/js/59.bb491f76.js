(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{268:function(t,r,e){"use strict";e.r(r);var a=e(0),n=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"golang-编码规范指南"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#golang-编码规范指南"}},[t._v("#")]),t._v(" Golang 编码规范指南")]),t._v(" "),e("p",[t._v("关于代码规范，每个公司、甚至每个团队都有不同的规范，并且有不同的理解。")]),t._v(" "),e("p",[t._v("这份编码规范是参考别的规范，结合自己的实际情况而修订的，并尝试着让身边的朋友也遵守这个。 核心的目的还是为了便于广阅读，减少可避免的 bug 和安全隐患。")]),t._v(" "),e("p",[t._v("如果你的代码没有办法找到下面的规范，那么就遵循标准库的规范，多阅读标准库的源码，标准库的代码可以说是写代码参考的标杆。")]),t._v(" "),e("h2",{attrs:{id:"行长约定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行长约定"}},[t._v("#")]),t._v(" 行长约定")]),t._v(" "),e("p",[t._v("一行最长不超过 80 个字符，超过的请使用换行展示，尽量保持格式优雅。\n如果使用 vim，请确认 ~/.vimrc 中设置有 set textwidth=80")]),t._v(" "),e("p",[t._v("网络在线, 频次随机(由讲师时间决定)")]),t._v(" "),e("h2",{attrs:{id:"package-名字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#package-名字"}},[t._v("#")]),t._v(" package 名字")]),t._v(" "),e("p",[t._v("保持 package 的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。")]),t._v(" "),e("h2",{attrs:{id:"import-规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#import-规范"}},[t._v("#")]),t._v(" import 规范")]),t._v(" "),e("p",[t._v("import 在多行的情况下，goimports 会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式：")]),t._v(" "),e("pre",[e("code",[t._v('import (\n    "fmt"\n)\n')])]),t._v(" "),e("p",[t._v("如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包：")]),t._v(" "),e("pre",[e("code",[t._v('import (\n    "encoding/json"\n    "strings"\n\n    "github.com/astaxie/beego"\n    "github.com/go-sql-driver/mysql"\n\n    "myproject/models"\n    "myproject/controller"\n    "myproject/utils"\n\n) \n')])]),t._v(" "),e("p",[t._v("有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是第三方包, 第三是项目包。")]),t._v(" "),e("p",[t._v("在项目中不要使用相对路径引入包：")]),t._v(" "),e("pre",[e("code",[t._v('import "../net"    // 这是不好的导入\nimport "github.com/name/repo/net" // 这是正确的做法\n')])]),t._v(" "),e("h2",{attrs:{id:"变量申明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量申明"}},[t._v("#")]),t._v(" 变量申明")]),t._v(" "),e("p",[t._v("变量名采用驼峰标准，不要使用 "),e("code",[t._v("_")]),t._v(" 来命名变量名，多个变量申明放在一起")]),t._v(" "),e("p",[t._v("在函数外部申明必须使用 var,不要采用 :=，容易踩到变量的作用域的问题。")]),t._v(" "),e("h2",{attrs:{id:"自定义类型的string循环问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义类型的string循环问题"}},[t._v("#")]),t._v(" 自定义类型的string循环问题")]),t._v(" "),e("p",[t._v("如果自定义的类型定义了 String 方法，那么在打印的时候会产生隐藏的一些 bug")]),t._v(" "),e("pre",[e("code",[t._v("type MyInt int\nfunc (m MyInt) String() string { \n    return fmt.Sprint(m)   //BUG:死循环\n}\n\nfunc(m MyInt) String() string { \n    return fmt.Sprint(int(m))   //这是安全的,因为我们内部进行了类型转换\n}\n")])]),t._v(" "),e("h2",{attrs:{id:"避免返回命名的参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免返回命名的参数"}},[t._v("#")]),t._v(" 避免返回命名的参数")]),t._v(" "),e("p",[t._v("返回变量及值，尽量在 func 行进行定义, 方便理解函数输入、输出。\nfunc foo(a int, b int) (status, msg string, flag bool){\n}")]),t._v(" "),e("h2",{attrs:{id:"错误处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[t._v("#")]),t._v(" 错误处理")]),t._v(" "),e("p",[t._v("错误处理的原则就是不能丢弃任何有返回 err 的调用，不要采用 "),e("code",[t._v("_")]),t._v("\n丢弃，必须全部处理。接到错误，要么返回 err，要么实在不行就 panic， 或者使用 Log\n记录下来。")]),t._v(" "),e("h2",{attrs:{id:"error-信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#error-信息"}},[t._v("#")]),t._v(" error 信息")]),t._v(" "),e("p",[t._v("error 的信息不要采用大写字母，尽量保持你的错误简短，但是要足够表达你的错误的意思。")]),t._v(" "),e("h2",{attrs:{id:"长句子打印或者调用，使用参数进行格式化分行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#长句子打印或者调用，使用参数进行格式化分行"}},[t._v("#")]),t._v(" 长句子打印或者调用，使用参数进行格式化分行")]),t._v(" "),e("p",[t._v("我们在调用 fmt.Sprint 或者 log.Sprint 之类的函数时，有时候会遇到很长的句子，我们需要在参数调用处进行多行分割：")]),t._v(" "),e("p",[t._v('下面是错误的方式：\nlog.Printf("A long format string: %s %d %d %s", myStringParameter, len(a),\nexpected.Size, defrobnicate(“Anotherlongstringparameter”,\nexpected.Growth.Nanoseconds() / 1e6))')]),t._v(" "),e("p",[t._v("应该是如下的方式：")]),t._v(" "),e("pre",[e("code",[t._v('log.Printf( \n    "A long format string: %s %d %d %s", \n    myStringParameter,\n    len(a),\n    expected.Size,\n    defrobnicate(\n        “Anotherlongstringparameter”,\n        expected.Growth.Nanoseconds() / 1e6, \n    ),\n)\n')])]),t._v(" "),e("h2",{attrs:{id:"注意闭包的调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注意闭包的调用"}},[t._v("#")]),t._v(" 注意闭包的调用")]),t._v(" "),e("p",[t._v("在循环中调用函数或者goroutine方法，一定要采用显示的变量调用，不要再闭包函数里面调用循环的参数")]),t._v(" "),e("pre",[e("code",[t._v("for i := 0; i < limit; i++ {\n    go func(){ DoSomething(i) }() //错误的做法\n    go func(i int){ DoSomething(i) }(i)//正确的做法\n}\n")])]),t._v(" "),e("p",[t._v("http://golang.org/doc/articles/race_detector.html#Race_on_loop_counter")]),t._v(" "),e("h2",{attrs:{id:"在逻辑处理中禁用-panic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在逻辑处理中禁用-panic"}},[t._v("#")]),t._v(" 在逻辑处理中禁用 panic")]),t._v(" "),e("p",[t._v("在main包中只有当实在不可运行的情况采用panic，例如文件无法打开，数据库无法连接导致程序无法")]),t._v(" "),e("p",[t._v("正常运行，但是对于其他的 package 对外的接口不能有 panic，只能在包内采用。")]),t._v(" "),e("p",[t._v("强烈建议在main包中使用 log.Fatal 来记录错误，这样就可以由 log 来结束程序。")]),t._v(" "),e("h2",{attrs:{id:"注释规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注释规范"}},[t._v("#")]),t._v(" 注释规范")]),t._v(" "),e("p",[t._v("注释可以帮我们很好的完成文档的工作，写得好的注释可以方便我们以后的维护。")]),t._v(" "),e("ol",[e("li",[t._v("注释符号与注释内容之前有且只有一个空格。如 // i += 2。")]),t._v(" "),e("li",[t._v("注释的缩进，与当前代码缩进保持一致, 禁止从首字符进行注释。")]),t._v(" "),e("li",[t._v("难以理解或是不符合 unix 常规的代码，需要上func 上方描述，并说明输入及输出。")])]),t._v(" "),e("p",[t._v("详细的如何写注释可以参考：http://golang.org/doc/effective_go.html#commentary")]),t._v(" "),e("h2",{attrs:{id:"bug注释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bug注释"}},[t._v("#")]),t._v(" bug注释")]),t._v(" "),e("p",[t._v("针对代码中出现的bug，可以采用如下教程使用特殊的注释，在godocs可以做到注释高亮：")]),t._v(" "),e("pre",[e("code",[t._v("// BUG(dean): This divides by zero. \nvar i float = 1/0\n")])]),t._v(" "),e("h2",{attrs:{id:"struct规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#struct规范"}},[t._v("#")]),t._v(" struct规范")]),t._v(" "),e("p",[t._v("struct申明和初始化格式采用多行：\n定义如下：")]),t._v(" "),e("pre",[e("code",[t._v("type User struct{\n    Username  string\n    Email     string\n}\n")])]),t._v(" "),e("p",[t._v("初始化如下：")]),t._v(" "),e("pre",[e("code",[t._v('u := User {\n    Username: "dean",\n    Email:    "dean@airdb.com",\n}\n')])]),t._v(" "),e("h2",{attrs:{id:"recieved是值类型还是指针类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#recieved是值类型还是指针类型"}},[t._v("#")]),t._v(" recieved是值类型还是指针类型")]),t._v(" "),e("p",[t._v("到底是采用值类型还是指针类型主要参考如下原则：")]),t._v(" "),e("p",[t._v("func(w Win) Tally(playerPlayer) int     // w不会有任何改变\nfunc(w *Win) Tally(playerPlayer) int    // w会改变数据")]),t._v(" "),e("p",[t._v("更多的请参考：https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Receiver_Type")]),t._v(" "),e("h2",{attrs:{id:"带-mutex-的-struct-必须是指针-receivers"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#带-mutex-的-struct-必须是指针-receivers"}},[t._v("#")]),t._v(" 带 mutex 的 struct 必须是指针 receivers")]),t._v(" "),e("p",[t._v("如果你定义的 struct 中带有 mutex, 那么你的 receivers 必须是指针")])])}),[],!1,null,null,null);r.default=n.exports}}]);