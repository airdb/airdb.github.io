(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{207:function(t,a,e){"use strict";e.r(a);var n=e(0),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"golang-开发入门"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#golang-开发入门"}},[t._v("#")]),t._v(" Golang 开发入门")]),t._v(" "),e("h2",{attrs:{id:"我的第一个-golang-程序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我的第一个-golang-程序"}},[t._v("#")]),t._v(" 我的第一个 Golang 程序")]),t._v(" "),e("h2",{attrs:{id:"解析范式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析范式"}},[t._v("#")]),t._v(" 解析范式")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://studygolang.com/articles/12023",target:"_blank",rel:"noopener noreferrer"}},[t._v("Go Channel的实现"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("G-P-M模型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("G:\n表示goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等；另外G对象是可以重用的。\nP:\n表示逻辑processor，P的数量决定了系统内最大可并行的G的数量（前提：系统的物理cpu核数>=P的数量）；P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。\nM:\nM代表着真正的执行计算资源。在绑定有效的p后，进入schedule循环；而schedule循环的机制大致是从各种队列、p的本地队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到m，如此反复。M并不保留G状态，这是G可以跨M调度的基础。\n")])])]),e("p",[e("img",{attrs:{src:"/images/goroutine-scheduler-model.png",alt:"",title:"goroutine"}})]),t._v(" "),e("p",[t._v("Plugin 热更新问题\nhttps://github.com/campoy/golang-plugins")])])}),[],!1,null,null,null);a.default=r.exports}}]);